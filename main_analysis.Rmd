---
title: "Bayesian metaanalysis of BBS phenotypes"
output: html_document
author: Martin Modr√°k
date: '`r format(Sys.time(), "%d %B, %Y")`'
---

```{r setup, echo=FALSE, message = FALSE}
knitr::opts_chunk$set(echo=FALSE)
library(rstan)
library(brms)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
library(skimr)
library(readxl)
library(here)
library(tidyverse)
library(tidybayes)
library(bayesplot)
library(cowplot)
library(knitr)


source(here("data_processing.R"))
source(here("modelling_base.R"))
source(here("plots.R"))


stored_fits_dir <- "stored_fits"
if(!dir.exists(here(stored_fits_dir))) {
  dir.create(here(stored_fits_dir))
}


```

*The complete source code for the analysis can be found at https://github.com/martinmodrak/bbs-metaanalysis-bayes *

# The data

First let us examine some of the properties of the data se we are working with - a brief summary follows.

```{r}
data <- read_main_data()
data %>%  select(-Age_corr, -ID, -age_numbers, -age_numbers_groups_guessed, -age_std_for_model) %>% skim()
```

Note in particular, that both age and sex are missing in almost half of the records. Also, the data about individual phenotypes (all the numeric columns) is largely incomplete. Some minor clearing is required to use age, as it is stored as character (a combination of age ranges and ages). For some phenotypes we get values that are not 0 or 1 - those correspond to patients that were monitored in multiple studies, but the phenotype data was inconsistent. In our analysis we treat those patients as exhibiting the phenotype.

For some analyses, we group the genes together according to *functional groups*, those are defined as folows:

```{r}
data %>% select(gene, functional_group) %>% distinct() %>% group_by(functional_group) %>% summarise(genes = paste(gene, collapse = ",")) %>% kable()
```

And here are the counts of individual mutations as observed in the data:

```{r}
data %>% group_by(gene) %>% summarise(count = length(gene)) %>% kable()
```

While we include all of the genes in our computational model, we will mostly show only the most frequent mutations in the results here, those include BBS01 through BBS10 and BBS12.

```{r}
genes_to_show <- genes_to_show_from_data(data)
data_long <- data_long_from_data(data)
```

On the other hand, we only include eight phenotypes in the model as those are our primary interest and including all phenotypes increased the computational burden of fitting the models.

```{r}
phenotypes_to_use
```


The data shows considerable between-study (source) variability (showing only the BBSome genes for clarity):

```{r}
data_long %>% 
  group_by(source, phenotype, gene) %>% 
  filter(functional_group == "BBSome", gene != "BBS18") %>%
  summarise(n_patients = length(phenotype_value), proportion = sum(phenotype_value) / n_patients) %>%
  ggplot(aes(x = gene, y = proportion, size = n_patients)) +
  geom_jitter(alpha = 0.3, height = 0, width = 0.3) +
  facet_wrap(~phenotype) +
  scale_y_continuous("Proportion of phenotype") +
  scale_size_continuous(range = c(0.5,4)) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust =0.5))
```

Here, every point represents the proportion of patients with a given mutation that manifested a given phenotype in one study. The point size represents the number of patients with the mutation in the study. We see that even studies with a relatively large number of patients do show very different proportions. We are therefore confident that allowing for between-study heterogeneity is important for analysing the data correctly. In the attached multiverse analysis, we also attempted to model the data as homogenous and found it to be a bad fit.

# Handling missingness

The most problematic missing data problem is the missingness in phenotype data. There are two distinct sources of missingness: a) a study missing the phenotype value for only some patients or b) a study not reporting the status of the phenotype for any patient. 
Our analysis assumes the phenotype data to be missing at random, i.e. that the decision to not report a given phenotype in a study and missingness for individual patients is independent of the prevalence of the phenotype in the study population. This is probably not true for missingness at the study level, as investigators are plausibly more likely to report more prevalent phenotypes and more likely to ignore phenotype that was not observed in any patient. Similarly, if data for a specific patient omits a given phenotype, it is more likely the phenotype was not present. 

However, in our analysis we were unable to find a good way to account for this phenomenon. This is a limitation of our approach and should be taken into account when interpreting the results. We however focus on comparison of phenotype incidence across different mutations and do not compare phenotypes against each other, so this is only an issue as far as the rate of missingness in phenotype values is correlated with the incidence of individual mutations present in a study (e.g. if studies with high phenotype missingness would also have overabundance of mutations in BBS03). Looking at the data at hand, a strong correlation of this type is implausible, but cannot be completely ruled out:

```{r}
phenotype_stats <- data_long %>% 
  group_by(ID, source) %>%
  summarise(n_pheno = length(phenotype)) %>%
  group_by(source) %>%
  summarise(avg_n_pheno = mean(n_pheno), n_patients = length(ID))

data_long %>%
  group_by(source, gene, functional_group) %>%
  summarise(n_mutations = length(unique(ID))) %>%
  inner_join(phenotype_stats, by = c("source" = "source")) %>%
  mutate(mutation_incidence = n_mutations / n_patients) %>%
  filter(functional_group %in% c("BBSome","BBS03"), gene != "BBS18" ) %>%
  ggplot(aes(x = avg_n_pheno, y = mutation_incidence, size = n_patients, weight = n_patients)) + 
  geom_smooth(method = "glm", family = "beta") +
  geom_jitter(alpha = 0.3) +
  guides(size = guide_legend(override.aes = list(alpha = 1))) +
  facet_wrap(~gene, scales = "free" )
```

In the figure above, each dot is a single study and show the average number of phenotypes reported per patient vs. the incidence of mutations in individual genes. Point size correspond to the number of patients in a given study.

There is large missingness in age and sex data as well. While our main analysis ignores age and sex, the attached multiverse analysis shows that after accounting for between-study differences, age and sex difference are already mostly accounted for. We have also tried to impute age and sex data and show that models including imputed age and/or sex provide almost identical results.

# The model - an accessible explanation

# The model - math

The model is specified with the following brms formula, using the Bernoulli family with logit link function:

```{r}
formula_gene_source
```

this can be expressed in the usual mathematical notation as:

$$
\begin{align}
Y_i &\sim Bernoulli(\mu_i) \\
\mathrm{logit}(\mu_i) &= \alpha + \beta^1_{p_i} + \beta^2_{p_i,g_i} + \beta^3_{p_i,s_i}
\end{align}
$$

Where $p_i \in \{1, ..., P \}$ is the index of the phenotype for $i$-th row, $g_i \in \{1,...,G\}$ is mutated gene for $i$-row and $s_i \in \{1,...,S\}$ is the index of the source study for $i$-th row. $\alpha$ is the intercept and $\beta^1, \beta^2$ and $\beta^3$ model the overall phenotype prevalence,  phenotype prevalance specific to a given mutation and between-study variability in phenotype prevalence respectively.

The priors we use for the parameters are:

$$
\begin{align}
\alpha &\sim N(0, 2) \\
\beta^1 &\sim N(0, \sigma_1) \\
\sigma_1 &\sim N(0, 2) \\

\beta^2 &\sim \mathcal{N}_P(\boldsymbol{0}, \boldsymbol{\Sigma}) \\
\boldsymbol{\Sigma} &= \boldsymbol{\sigma}_2  \bar{\boldsymbol{\Sigma}} \\
\bar{\boldsymbol{\Sigma}} &\sim LKJ_P(1) \\
\sigma_{2,p} &\sim N(0, 2) \\

\beta^3_{p,s} &\sim  N(0, \sigma_{3,p})\\
\sigma_{3,p} &\sim N(0, 2)
\end{align}
$$

Note that the prior on $\beta^1$ is $P$-dimensional multivariete normal $\mathcal{N}_P$, explicitly modelling the correlation $\bar{\boldsymbol{\Sigma}}$ between the incidence of individual phenotypes, while the other priors are univariete normal.

The attached multiverse analysis shows that the results are almost identical when the priors are different.

# Main results

```{r}

priors <- c(intercept_prior, sd_prior)

#The file argument
fit_gene_source <- brm(formula_gene_source, prior = priors, data = data_long, control = list(adapt_delta = 0.9),
                     file = here(stored_fits_dir,"gene_source"))
fit_gene_source
#run_pp_checks(fit_gene_source, data_long)
```

```{r}
data_for_prediction_gene_source <- tibble(gene = genes_to_show, source = "new_source") %>%
    crossing(tibble(phenotype = phenotypes_to_show)) %>% mutate(functional_group = functional_group_for_gene(gene))

data_for_prediction_gene_source_BBSome <- data_for_prediction_gene_source %>% filter(functional_group_for_gene(gene) == "BBSome", gene != "BBS18")
```

# Summaries of mutation effects

## Summary for functional groups

Posterior 95% (thin) and 50% (thick) credible intervals for ratio of odds for a phenotype given a random mutation within a functional group to odds for the phenotype given a random mutation across all groups shown. All mutations are assumed to be equally likely - the odds are not weighed by the frequency of the mutations in the dataset. Odds ratios are shown on the log scale and each phenotype has its own scale. Gray dots show the same odds ratio calculated for individual studies included in the metanalysis. Dots below the dashed lines correspond to studies where the empirical odds ratio is 0 or infinity. Dot size represents the number of relevant cases in the study.


```{r, fig.width=8, fig.height=4}
differences_func_group_plot <- plot_gene_phenotype_differences_estimates(fit_gene_source, data_for_prediction_gene_source %>% mutate(group = functional_group), genes_to_show = genes_to_show, group_title = "Functional group", data_original = data_long %>% mutate(group = functional_group))
differences_func_group_plot
```

## Summary for BBSome genes

Posterior 95% (thin) and 50% (thick) credible intervals for ratio of odds for a phenotype given a mutation in a gene to odds for the phenotype given a random mutation across all genes shown. All mutations are assumed to be equally likely - the odds are not weighed by the frequency of the mutations in the dataset. Odds ratios are shown on the log scale and each phenotype has its own scale. Gray dots show the same odds ratio calculated for individual studies included in the metanalysis. Dots below the dashed lines correspond to studies where the empirical odds ratio is 0 or infinity. Dot size represents the number of relevant cases in the study.

```{r, fig.width=8, fig.height=4}
differences_bbsome_plot <- plot_gene_phenotype_differences_estimates(fit_gene_source, data_for_prediction_gene_source_BBSome, genes_to_show = genes_to_show, data_original = data_long)
differences_bbsome_plot #TODO lines to separate extreme studies (prob better than color separations)
```

# Pairwise comparisons of mutations in BBSome genes

The most conservative (closest to one) pairwise odds ratios within 95% posterior credible intervals.
The reported odds ratio are for gene on the horizontal axis against the gene on the vertical axis.

```{r, fig.width=8, fig.height=4}
plot_pairwise_differences(fit_gene_source, data_for_prediction_gene_source_BBSome,  "heatmap_min")
```

The most extreme (furthest from one) pairwise odds ratios within 95% posterior credible intervals.
The direction of the effect is not reported as effects in both directions might be similarly plausible - the  odds ratio are transformed to be larger than one in all cases.


```{r, fig.width=8, fig.height=4}

plot_pairwise_differences(fit_gene_source, data_for_prediction_gene_source_BBSome, plot_types = "heatmap_max")
```

Posterior 95% (thin) and 50% (thick) credible intervals for odds ratio for a phenotype given mutation in the gene on horizontal axis against the gene on the vertical axis. Color indicates the widest central posterior credible interval that does not include one. Odds ratio are shown on the log scale.

```{r, fig.width=10, fig.height=7}
plot_pairwise_differences(fit_gene_source, data_for_prediction_gene_source_BBSome, plot_types = "linerange_all")

```

# Saving figures for publication

```{r}
std_width = 8
std_height = 4
img_path = here("tmp_pics")
if(!dir.exists(img_path)) {
  dir.create(img_path)
}
types = c(".eps",".png")

for(type in types) {
  differences_func_group_plot %>% ggsave(paste0("functional_groups", type), plot = ., path = img_path,height = std_height, width = 5)
  
  differences_bbsome_plot %>% ggsave(paste0("bbsome_overall", type), plot = ., path = img_path,height = std_height, width = std_width)
  
  plot_pairwise_differences(fit_gene_source, data_for_prediction_gene_source_BBSome, plot_types = c("heatmap_min", "heatmap_max"), out_func = function(name, plot) {
    ggsave(paste0(name, type), plot = plot, path = img_path,height = std_height, width = std_width)
  })
  
  plot_pairwise_differences(fit_gene_source, data_for_prediction_gene_source_BBSome, plot_types = "linerange_all", out_func = function(name, plot) {
    ggsave(paste0(name, type), plot = plot, path = img_path,height = 7, width = 10)
  })
}
```

Checking the LIV phenotype

```{r}
data_long %>% filter(phenotype == "LIV") %>% group_by(functional_group) %>%
 summarise(avg_phenotype = mean(phenotype_value))
```


```{r}
pos = position_jitterdodge(dodge.width = 0.3, jitter.width = 0, jitter.height = 0.02)

plot_liv_source <-  data_long %>% filter(phenotype == "LIV", functional_group != "Others") %>% 
  group_by(functional_group, source) %>%
  summarise(avg_phenotype = mean(phenotype_value), num_cases = length(phenotype_value)) %>% 
  droplevels() %>%
  ggplot(aes(x = functional_group, y = avg_phenotype, group = source, color = source)) + 
  geom_line(alpha = 0.5, position = pos) + geom_point(aes(size = num_cases), position = pos, alpha = 0.5) + guides(color = FALSE)

plot_liv_source

for(type in ".png") {
  ggsave(paste0("liv_by_source", type), plot = plot_liv_source, path = img_path, height = std_height, width = std_width)
}
```


```{r}
sessionInfo()
```

